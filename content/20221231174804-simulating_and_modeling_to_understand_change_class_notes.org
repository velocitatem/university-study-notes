:PROPERTIES:
:ID:       a66d2149-cb01-4124-bcc8-c5e9f1669d3d
:END:
#+title: Simulating and Modeling to Understand Change - Class Notes
#+HTML_HEAD: <link rel="stylesheet" href="https://alves.world/org.css" type="text/css">
#+HTML_HEAD: <style type="text/css" media="print"> body { visibility: hidden; display: none } </style>
#+OPTIONS: toc:2
#+HTML_HEAD: <script src="https://alves.world/tracking.js" ></script>
#+HTML_HEAD: <script src="anti-cheat.js"></script>
#+HTML: <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="velocitatem24" data-description="Support me on Buy me a coffee!" data-message="" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
#+HTML: <script>setTimeout(() => {alert("Finding this useful? Consider buying me a coffee! Bottom right cornner :) Takes just a few seconds")}, 60*1000);_paq.push(['trackEvent', 'Exposure', 'Exposed to beg']);</script>





#+HTML: <footer style="height: 20vh;"></footer>


* Introduction
** Systems
A system is a group of objects that work together to achieve a goal. It consists of two environments: the inside and the outside. Each entity in the system has attributes or can do activities. A state can be defined for the system or components of the system. Examples of systems include computer systems, forests, restaurants, and banks. The key components of a system are the entities, attributes, activities, states, and events. Systems can be either discrete or continuous, such as the people in a bank or the water levels in a river.
** Models
A model is an abstraction of a real-life situation, where the complexity of the model increases with the number of variables that are taken into account. The simplicity or realism of a model is determined by how closely it reflects the actual situation it is representing.
** Simulation

Simulation is a great tool to use when attempting to gain insights into the behavior of complex systems. Stochastic simulations rely on randomness to predict events, while deterministic simulations are based on predetermined inputs. For example, a restaurant/shop system can be simulated by making assumptions about the number of customers and employees in the system. Simulations are advantageous because they are cheaper, faster, replicable, safer, ethical, and legal when compared to real-life experiments. The decision between using a stochastic or deterministic simulation depends on the circumstances and the desired outputs.
*** Deterministic

In physics, determinism is the idea that all events are predetermined. There is no room for randomness or probability, as all changes are predetermined by the laws of nature. An example of this is an account gaining and losing followers, which is predetermined by the actions of the account holder. To simulate this process in Python, one could create a loop that tracks the number of followers gained and lost over time and stores it in a variable. This variable could then be used to print out the number of followers at any given time.
*** Stochastic
# stochastic - has randomness, uses random variables
Stochastic simulation is a modelling technique which incorporates randomness, making use of random variables to generate a variety of possible outcomes. It is used for analysing complex systems in which the effects of randomness cannot be predicted deterministically, and thus provides a useful tool for predicting and understanding the behaviour of such systems.
*** Statics vs Dynamic
# Static: there is no time variable
# Dymanic: there is a time variable
Simulations are typically classified as either static or dynamic. In a static simulation, there is no time variable; the system is unchanging and the same set of conditions is used throughout the simulation. In a dynamic simulation, time is a variable, meaning that the system is constantly changing and the conditions of the simulation can evolve over time.
** A Seed
# it can be any number
# allows us to replicate semi-random experiments
A seed is any number that can be used to replicate semi-random experiments and simulations. It allows for the same experiment to be repeated in the same way, with the same conditions and results, by using the same seed each time. This makes it easy to compare results from different experiments and simulations, as the same starting point can be replicated.

* Random Numbers Generation
+ getting randomness is almost impossible
+ People confuse randomness with strangeness
+ Continuous distribution to discrete on range 0 to 1 - can be done by rounding
+ Properties of pseudo-random numbers: uniform, independent, unpredictable
+ Testing the randomness of a sequence of numbers:
  + Look at the distribution of the numbers (visual) - should be uniform
  + See if there is any pattern
+ Algorithms:
  + must be fast
  + must be long
  + should be repeatable with a seed
+ Setting seed in python =random.seed(2023)=
+ We can generate $n$ random numbers with python by using =np.random.uniform(min,max,nax)=

** Linear Congruential Method
+ We get a random like pattern.
+ It is a linear transformation of a previous number
+ Equation: $x_{n} = (a x_{n-1} + c) \mod m$
#+begin_src python :results output

  import numpy as np
  def LCM(n, seed, a, c, m):
      x = [seed]
      for i in range(1,n+1):
          x.append((a*x[i-1] + c) % m)
      u = np.array(x)/m
      return u

  seq =LCM(n=8, seed=4, a=13, c=0, m=64)
  print(seq)
#+end_src

#+RESULTS:
: [0.0625 0.8125 0.5625 0.3125 0.0625 0.8125 0.5625 0.3125 0.0625]

+ Those results are pretty bad
* Testing Randomness
To check if we have an actually random generator, we need to test *uniformity* and *independence*.
** Testing Uniformity
+ We test using hypothesis testing
  + Null hypothesis = sequence is uniform
  + Alternative hypothesis = sequence is not uniform
+ We use an alpha level of 0.05. If our $p$ is less than 0.05 we reject the null hypothesis, otherwise we fail to reject the null hypothesis
+ We want to fail to reject the null hypothesis to have uniformity.
+ The test we use is *Kolmogrov-Smirnov* test
+ We use the function =stats.kstest= from the =scipy.stats= library

** Testing Independence
+ We again make use of hypothesis testing
  + Null hypothesis = sequence is independent
  + Alternative hypothesis = sequence is not independent
+ To test for the dependence of each number, we use correlation
+ The specific type of correlation we use is *autocorrelation*
  + This means that we correlate the number and the sequence
+ When we auto-correlate, we need to have a lag
  + This is the number of steps we take ahead in the sequence
+ We can use a pandas data frame:
#+begin_src python :tangle yes :results file :exports both :noweb yes
  import numpy as np
  import pandas as pd
  import matplotlib.pyplot as plt
  seq = np.random.uniform(0,1,100)
  df = pd.DataFrame(seq, columns=['values'])
  pd.plotting.autocorrelation_plot(df['values'])
  plt.savefig("autocorrelation.png")
  return "autocorrelation.png"
#+end_src

#+RESULTS:
[[file:./autocorrelation.png]]

In the above plot:
+ If the line is within the dashed lines, we fail to reject the null hypothesis

We need a more robust way of assessing if the sequence is independent:
#+begin_src python :tangle yes :results output :exports both :noweb yes
  acf, confint = statstools.acf(seq, alpha=0.05, nlags=10)
  lbvalue, pvalue = statstools.q_stat(acf[1:], len(seq))
  print("p-value: ", pvalue)
#+end_src

Now we can use the p-value to test for independence.


* Random Variable Simulation

* Monte Carlo Simulation
First, what is the Monte Carlo method? It is the aggregation of multiple simulations, to infer something.

Characteristics:
+ Randomness - has to have a large period between repeats
+ Large sample
+ Valid algorithm
+ Accurately simulates
** Process
1. Define the domain of imputes
2. Generate the inputs from a distribution
3. Run a deterministic simulation
4. Replicate
5. Aggregate
** Inferential Statistics
+ We use inferential statistics to make inferences about a population from a sample
+ We simulate a sample, calculate the statistics and then use the statistics to make inferences about the population
* Discrete Events Simulation
* Model Building
* Regression Models
* Classification Models
